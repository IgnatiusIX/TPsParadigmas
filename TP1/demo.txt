∀ us :: Universo . ∀ o :: Objeto . elem o (objetos_en us) ⇒ elem (Right o) us

Vamos a probar esto por inducción sobre us.

	P(us) = ∀ o :: Objeto . elem o (objetos_en us) ⇒ elem (Right o) us

Queremos probar P(us) ⇒ P(u:us).
Utilizaremos las siguientes equivalencias, aplicables según el Principio de Reemplazo:
	{F0} foldr _ z [] = z
	{F1} foldr f z (a:as) = f a (foldr f z as)
	{E0} elem a [] = False
	{E1} elem a (x:xs) = a == x || elem a xs
	{OBEN} objetos_en = filterMap es_un_objeto objetos_de
	{FM} filterMap f g = foldr (\elem rec -> if f elem then g elem : rec else rec) []

A su vez, para funciones lambda, utilizaremos la reducción beta: 
	{RedBeta} (\x -> M) y ⇒ M{x:=y}
	-- Notar que abusaremos la notación, reemplazando todas las variables de una función lambda en un solo paso.
	-- Por ejemplo, (\a b ⇒ M) c d ⇒ M' (donde M' = M{a:=c}{b:=d})
	-- En estos casos, ⇒ se entiende como la relación de 'reduce a'.

Caso Base {

	Queremos ver que se cumpla P([]), es decir el caso base para us.

	elem o (objetos_en []) ⇒ elem (Right o) [] =

{OBEN} = elem o (filterMap es_un_objeto objeto_de []) ⇒ elem (Right o) [] =

{FM} = elem o (foldr (\elem rec -> if es_un_objeto elem then objeto_de elem : rec else rec) [] []) ⇒ elem (Right o) [] =

{F0} = elem o [] ⇒ elem (Right o) [] =

{E0} = False ⇒ _ =
	
= True □

} 

Caso Inductivo {

	Asumimos P(us) verdad. Luego, queremos ver que P(u:us) se cumpla, con 'u :: Either Personaje Objeto'.
	Desarrollamos P(u:us) usando el Principio de Reemplazo en la parte izquierda de la implicación:

	elem o (objetos_en (u:us)) ⇒ elem (Right o) (u:us) =

{OBEN} = elem o (filterMap es_un_objeto objeto_de (u:us)) ⇒ elem (Right o) (u:us) =

{FM} =	elem o (foldr (\elem rec -> if es_un_objeto elem then objeto_de elem : rec else rec) [] (u:us)) ⇒ elem (Right o) (u:us) =

{F1} =	elem o ((\elem rec -> if es_un_objeto elem then objeto_de elem : rec else rec) u (foldr FL* [] us)) ⇒ elem (Right o) (u:us) ⇒

* Llamamos "FL" a la Funcion Lambda que le pasamos a foldr: '(\elem rec -> if es_un_objeto elem then objeto_de elem : rec else rec)'
		
{RedBeta} ⇒ elem o (if es_un_objeto u then objeto_de u:(foldr f [] us) else (foldr f [] us)) ⇒ elem (Right o) (u:us)
! Hasta acá llegué
			Veamos que por Principio de Reemplazo, foldr f z us = objetos_en us

				foldr f [] us = foldr (\elem rec -> if es_un_objeto elem then objeto_de elem : rec else rec) [] us

				= filterMap es_un_objeto objeto_de us = objetos_en us

		Luego tenemos que:

		elem o (if es_un_objeto u then objeto_de u:objetos_en us else objetos_en us) ⇒ elem (Right o) (u:us)
 		
	Por Extensionalidad de Booleanos es_un_objeto u es igual a True o False, luego tenemos dos casos:
		
	- Caso donde 'es_un_objeto u' es falso - {

		Desarrollando aún más nos queda algo de la forma:

			elem o (objetos_en us) ⇒ (Right o) == u || elem (Right o) us

		Como u no es del tipo 'Right x', con x :: Objeto,
		por cómo funciona la igualdad entre objetos de
		tipo Either A B, sabemos que '(Right o) == u' es falso. Luego,

			elem o (objetos_en us) ⇒ False || elem (Right o) us

			elem o (objetos_en us) ⇒ elem (Right o) us

			Por HI

				True

	}

	- Caso donde 'es_un_objeto u' es verdad - {

		Desarrollando aún más nos queda algo de la forma:

			elem o ((objetos_de u) : objetos_en us) ⇒ (Right o) == u || elem (Right o) us

			o == (objeto_de u) || elem o (objetos_de us) ⇒ (Right o) == u || elem (Right o) us

		Tomamos u = (Right x), para algún x :: Objeto

		Entonces 

			objeto_de u = objeto_de (Right x) = x

		Por lo que reemplazando quedaria

			o == x || elem o (objetos_de us) ⇒ (Right o) == (Right x) || elem (Right o) us
		
		Por Extensionalidad de Booleanos x == o es True o False:
		Si x == o {

			o == x || elem o (objetos_de us) ⇒ (Right o) == (Right x) || elem (Right o) us

			o == o || elem o (objetos_de us) ⇒ (Right o) == (Right o) || elem (Right o) us

			True || elem o (objetos_de us) ⇒ True || elem (Right o) us

			True || _ ⇒ True || _ 
				 
			True ⇒ True

			True

		} Ahora si x != o {

			o == x || elem o (objetos_de us) ⇒ (Right o) == (Right x) || elem (Right o) us

			False || elem o (objetos_de us) ⇒ False || elem (Right o) us

			elem o (objetos_de us) ⇒ elem (Right o) us

			Por HI

				True

		}
	}
}
